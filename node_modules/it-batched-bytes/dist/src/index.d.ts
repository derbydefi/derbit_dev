import { Uint8ArrayList } from 'uint8arraylist';
export interface BatchedBytesOptions {
    /**
     * The minimum number of bytes that should be in a batch (default: 1MB)
     */
    size?: number;
}
export interface AsyncBatchedBytesOptions extends BatchedBytesOptions {
    /**
     * If this amount of time passes, yield all the bytes in the batch even
     * if they are below `size` (default: 0 - e.g. on every tick)
     */
    yieldAfter?: number;
}
export interface BatchedObjectsOptions<T> extends BatchedBytesOptions {
    /**
     * This function should serialize the object and append the
     * result to the passed list
     */
    serialize: (object: T, list: Uint8ArrayList) => void;
}
export interface AsyncBatchedObjectsOptions<T> extends AsyncBatchedBytesOptions, BatchedObjectsOptions<T> {
}
/**
 * Takes a stream of Uint8Arrays and/or Uint8ArrayLists and store them in
 * an internal buffer. Either once the buffer reaches the requested size
 * or the next event loop tick occurs, yield any bytes from the buffer.
 */
declare function batchedBytes(source: Iterable<Uint8Array | Uint8ArrayList>, options?: BatchedBytesOptions): Iterable<Uint8Array>;
declare function batchedBytes(source: Iterable<Uint8Array | Uint8ArrayList> | AsyncIterable<Uint8Array | Uint8ArrayList>, options?: AsyncBatchedBytesOptions): AsyncIterable<Uint8Array>;
declare function batchedBytes<T>(source: Iterable<T>, options?: BatchedObjectsOptions<T>): Iterable<Uint8Array>;
declare function batchedBytes<T>(source: Iterable<T> | AsyncIterable<T>, options?: AsyncBatchedObjectsOptions<T>): AsyncIterable<Uint8Array>;
export default batchedBytes;
//# sourceMappingURL=index.d.ts.map